# -*- coding: utf-8 -*-
"""8 puzzle problem dfs.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pAcjLY7iGPCG6HPKYBCBFUJQWtbpTCWs
"""

def is_valid(state):
    return len(state) == 9 and sorted(state) == list(range(9))


def print_state(state):
    for i in range(0, 9, 3):
        print(' '.join(str(x) if x != 0 else ' ' for x in state[i:i+3]))
    print("-" * 5)


def manhattan_distance(state, goal_state):
    """
    Compute sum of Manhattan distances for all tiles from current to goal positions.
    """
    distance = 0
    for num in range(1, 9):  # ignore blank tile 0
        current_index = state.index(num)
        goal_index = goal_state.index(num)
        current_row, current_col = divmod(current_index, 3)
        goal_row, goal_col = divmod(goal_index, 3)
        distance += abs(current_row - goal_row) + abs(current_col - goal_col)
    return distance


def get_neighbors(state):
    neighbors = []
    zero_index = state.index(0)
    row, col = divmod(zero_index, 3)

    moves = {
        'Right': (0, 1),
        'Left': (0, -1),
        'Down': (1, 0),
        'Up': (-1, 0)
    }

    for move, (dr, dc) in moves.items():
        new_row, new_col = row + dr, col + dc
        if 0 <= new_row < 3 and 0 <= new_col < 3:
            new_zero_index = new_row * 3 + new_col
            new_state = list(state)
            new_state[zero_index], new_state[new_zero_index] = new_state[new_zero_index], new_state[zero_index]
            neighbors.append((tuple(new_state), move))
    return neighbors


def dfs_heuristic(initial_state, goal_state, max_depth=10000):
    """
    DFS with heuristic-guided neighbor exploration.
    Returns (path, moves) or (None, None).
    """
    stack = [(initial_state, [], [], 0)]  # (state, path, moves, depth)
    visited = set()

    while stack:
        current_state, path, moves, depth = stack.pop()

        if current_state == goal_state:
            return path + [current_state], moves

        if current_state not in visited and depth < max_depth:
            visited.add(current_state)
            neighbors = get_neighbors(current_state)

            # Sort neighbors by heuristic: prefer states closer to goal
            neighbors.sort(key=lambda x: manhattan_distance(x[0], goal_state), reverse=True)
            # reverse=True because stack is LIFO, we want the smallest heuristic neighbor to be popped first

            for neighbor_state, move in neighbors:
                stack.append((neighbor_state, path + [current_state], moves + [move], depth + 1))

    return None, None


def input_state(prompt):
    while True:
        raw = input(prompt)
        parts = raw.strip().split()
        if len(parts) != 9:
            print("Enter exactly 9 numbers separated by spaces.")
            continue
        try:
            numbers = tuple(int(x) for x in parts)
        except ValueError:
            print("Please enter integers only.")
            continue
        if not is_valid(numbers):
            print("Numbers must be 0 through 8 exactly once each.")
            continue
        return numbers


if __name__ == "__main__":
    print("Enter initial state (0 for blank):")
    initial_state = input_state("Enter 9 numbers separated by spaces: ")

    print("\nInitial state:")
    print_state(initial_state)

    print("Enter goal state (0 for blank):")
    goal_state = input_state("Enter 9 numbers separated by spaces: ")

    print("\nGoal state:")
    print_state(goal_state)

    solution_path, solution_moves = dfs_heuristic(initial_state, goal_state)

    if solution_path:
        print(f"\nSolution found in {len(solution_moves)} moves!\n")
        for i in range(len(solution_moves)):
            print(f"Move {i + 1}: {solution_moves[i]}")
            print_state(solution_path[i + 1])
    else:
        print("No solution found.")
